{"remainingRequest":"/Users/pstaab/code/standards-grading/node_modules/babel-loader/lib/index.js!/Users/pstaab/code/standards-grading/node_modules/vuex-module-decorators/dist/esm/index.js","dependencies":[{"path":"/Users/pstaab/code/standards-grading/node_modules/vuex-module-decorators/dist/esm/index.js","mtime":1588951530997},{"path":"/Users/pstaab/code/standards-grading/node_modules/cache-loader/dist/cjs.js","mtime":1588951537868},{"path":"/Users/pstaab/code/standards-grading/node_modules/babel-loader/lib/index.js","mtime":1588951537846}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2giOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX3R5cGVvZiBmcm9tICIvVXNlcnMvcHN0YWFiL2NvZGUvc3RhbmRhcmRzLWdyYWRpbmcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZiI7CgovKioNCiAqIFRha2VzIHRoZSBwcm9wZXJ0aWVzIG9uIG9iamVjdCBmcm9tIHBhcmFtZXRlciBzb3VyY2UgYW5kIGFkZHMgdGhlbSB0byB0aGUgb2JqZWN0DQogKiBwYXJhbWV0ZXIgdGFyZ2V0DQogKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0ICBPYmplY3QgdG8gaGF2ZSBwcm9wZXJ0aWVzIGNvcGllZCBvbnRvIGZyb20geQ0KICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSAgT2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBiZSBjb3BpZWQgdG8geA0KICovCmZ1bmN0aW9uIGFkZFByb3BlcnRpZXNUb09iamVjdCh0YXJnZXQsIHNvdXJjZSkgewogIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gX2xvb3BfMShrKSB7CiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrLCB7CiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgIHJldHVybiBzb3VyY2Vba107CiAgICAgIH0KICAgIH0pOwogIH07CgogIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhzb3VyY2UgfHwge30pOyBfaSA8IF9hLmxlbmd0aDsgX2krKykgewogICAgdmFyIGsgPSBfYVtfaV07CgogICAgX2xvb3BfMShrKTsKICB9Cn0KLyoqDQogKiBSZXR1cm5zIGEgbmFtZXNwYWNlZCBuYW1lIG9mIHRoZSBtb2R1bGUgdG8gYmUgdXNlZCBhcyBhIHN0b3JlIGdldHRlcg0KICogQHBhcmFtIG1vZHVsZQ0KICovCgoKZnVuY3Rpb24gZ2V0TW9kdWxlTmFtZShtb2R1bGUpIHsKICBpZiAoIW1vZHVsZS5fdm1kTW9kdWxlTmFtZSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJFUlJfR0VUX01PRFVMRV9OQU1FIDogQ291bGQgbm90IGdldCBtb2R1bGUgYWNjZXNzb3IuXG4gICAgICBNYWtlIHN1cmUgeW91ciBtb2R1bGUgaGFzIG5hbWUsIHdlIGNhbid0IG1ha2UgYWNjZXNzb3JzIGZvciB1bm5hbWVkIG1vZHVsZXNcbiAgICAgIGkuZS4gQE1vZHVsZSh7IG5hbWU6ICdzb21ldGhpbmcnIH0pIik7CiAgfQoKICByZXR1cm4gInZ1ZXhNb2R1bGVEZWNvcmF0b3JzLyIgKyBtb2R1bGUuX3ZtZE1vZHVsZU5hbWU7Cn0KCnZhciBWdWV4TW9kdWxlID0KLyoqIEBjbGFzcyAqLwpmdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gVnVleE1vZHVsZShtb2R1bGUpIHsKICAgIHRoaXMuYWN0aW9ucyA9IG1vZHVsZS5hY3Rpb25zOwogICAgdGhpcy5tdXRhdGlvbnMgPSBtb2R1bGUubXV0YXRpb25zOwogICAgdGhpcy5zdGF0ZSA9IG1vZHVsZS5zdGF0ZTsKICAgIHRoaXMuZ2V0dGVycyA9IG1vZHVsZS5nZXR0ZXJzOwogICAgdGhpcy5uYW1lc3BhY2VkID0gbW9kdWxlLm5hbWVzcGFjZWQ7CiAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGUubW9kdWxlczsKICB9CgogIHJldHVybiBWdWV4TW9kdWxlOwp9KCk7CgpmdW5jdGlvbiBnZXRNb2R1bGUobW9kdWxlQ2xhc3MsIHN0b3JlKSB7CiAgdmFyIG1vZHVsZU5hbWUgPSBnZXRNb2R1bGVOYW1lKG1vZHVsZUNsYXNzKTsKCiAgaWYgKHN0b3JlICYmIHN0b3JlLmdldHRlcnNbbW9kdWxlTmFtZV0pIHsKICAgIHJldHVybiBzdG9yZS5nZXR0ZXJzW21vZHVsZU5hbWVdOwogIH0gZWxzZSBpZiAobW9kdWxlQ2xhc3MuX3N0YXRpY3MpIHsKICAgIHJldHVybiBtb2R1bGVDbGFzcy5fc3RhdGljczsKICB9CgogIHZhciBnZW5TdGF0aWMgPSBtb2R1bGVDbGFzcy5fZ2VuU3RhdGljOwoKICBpZiAoIWdlblN0YXRpYykgewogICAgdGhyb3cgbmV3IEVycm9yKCJFUlJfR0VUX01PRFVMRV9OT19TVEFUSUNTIDogQ291bGQgbm90IGdldCBtb2R1bGUgYWNjZXNzb3IuXG4gICAgICBNYWtlIHN1cmUgeW91ciBtb2R1bGUgaGFzIG5hbWUsIHdlIGNhbid0IG1ha2UgYWNjZXNzb3JzIGZvciB1bm5hbWVkIG1vZHVsZXNcbiAgICAgIGkuZS4gQE1vZHVsZSh7IG5hbWU6ICdzb21ldGhpbmcnIH0pIik7CiAgfQoKICB2YXIgc3RvcmVNb2R1bGUgPSBnZW5TdGF0aWMoc3RvcmUpOwoKICBpZiAoc3RvcmUpIHsKICAgIHN0b3JlLmdldHRlcnNbbW9kdWxlTmFtZV0gPSBzdG9yZU1vZHVsZTsKICB9IGVsc2UgewogICAgbW9kdWxlQ2xhc3MuX3N0YXRpY3MgPSBzdG9yZU1vZHVsZTsKICB9CgogIHJldHVybiBzdG9yZU1vZHVsZTsKfQoKdmFyIHJlc2VydmVkS2V5cyA9IFsnYWN0aW9ucycsICdnZXR0ZXJzJywgJ211dGF0aW9ucycsICdtb2R1bGVzJywgJ3N0YXRlJywgJ25hbWVzcGFjZWQnLCAnY29tbWl0J107CgpmdW5jdGlvbiBzdGF0ZUZhY3RvcnkobW9kdWxlKSB7CiAgdmFyIHN0YXRlID0gbmV3IG1vZHVsZS5wcm90b3R5cGUuY29uc3RydWN0b3Ioe30pOwogIHZhciBzID0ge307CiAgT2JqZWN0LmtleXMoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgaWYgKHJlc2VydmVkS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSB7CiAgICAgIGlmICh0eXBlb2Ygc3RhdGVba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkVSUl9SRVNFUlZFRF9TVEFURV9LRVlfVVNFRDogWW91IGNhbm5vdCB1c2UgdGhlIGZvbGxvd2luZ1xuICAgICAgICBbJ2FjdGlvbnMnLCAnZ2V0dGVycycsICdtdXRhdGlvbnMnLCAnbW9kdWxlcycsICdzdGF0ZScsICduYW1lc3BhY2VkJywgJ2NvbW1pdCddXG4gICAgICAgIGFzIGZpZWxkcyBpbiB5b3VyIG1vZHVsZS4gVGhlc2UgYXJlIHJlc2VydmVkIGFzIHRoZXkgaGF2ZSBzcGVjaWFsIHB1cnBvc2UgaW4gVnVleCIpOwogICAgICB9CgogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKHN0YXRlLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgaWYgKHR5cGVvZiBzdGF0ZVtrZXldICE9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgc1trZXldID0gc3RhdGVba2V5XTsKICAgICAgfQogICAgfQogIH0pOwogIHJldHVybiBzOwp9Ci8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuDQpMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlDQp0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZQ0KTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjANCg0KVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWQ0KS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRA0KV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSwNCk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuDQoNClNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucw0KYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi8KCgpmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7CiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsKICAgICAgdHJ5IHsKICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICByZWplY3QoZSk7CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgewogICAgICB0cnkgewogICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyJ0aHJvdyJdKHZhbHVlKSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICByZWplY3QoZSk7CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgewogICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7CiAgICAgICAgcmVzb2x2ZShyZXN1bHQudmFsdWUpOwogICAgICB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOwogICAgfQoKICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTsKICB9KTsKfQoKZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkgewogIHZhciBfID0gewogICAgbGFiZWw6IDAsCiAgICBzZW50OiBmdW5jdGlvbiBzZW50KCkgewogICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07CiAgICAgIHJldHVybiB0WzFdOwogICAgfSwKICAgIHRyeXM6IFtdLAogICAgb3BzOiBbXQogIH0sCiAgICAgIGYsCiAgICAgIHksCiAgICAgIHQsCiAgICAgIGc7CiAgcmV0dXJuIGcgPSB7CiAgICBuZXh0OiB2ZXJiKDApLAogICAgInRocm93IjogdmVyYigxKSwKICAgICJyZXR1cm4iOiB2ZXJiKDIpCiAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgewogICAgcmV0dXJuIHRoaXM7CiAgfSksIGc7CgogIGZ1bmN0aW9uIHZlcmIobikgewogICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7CiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7CiAgICB9OwogIH0KCiAgZnVuY3Rpb24gc3RlcChvcCkgewogICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy4iKTsKCiAgICB3aGlsZSAoXykgewogICAgICB0cnkgewogICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbInJldHVybiJdIDogb3BbMF0gPyB5WyJ0aHJvdyJdIHx8ICgodCA9IHlbInJldHVybiJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDsKICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07CgogICAgICAgIHN3aXRjaCAob3BbMF0pIHsKICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgdCA9IG9wOwogICAgICAgICAgICBicmVhazsKCiAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgIF8ubGFiZWwrKzsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sCiAgICAgICAgICAgICAgZG9uZTogZmFsc2UKICAgICAgICAgICAgfTsKCiAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgIF8ubGFiZWwrKzsKICAgICAgICAgICAgeSA9IG9wWzFdOwogICAgICAgICAgICBvcCA9IFswXTsKICAgICAgICAgICAgY29udGludWU7CgogICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpOwoKICAgICAgICAgICAgXy50cnlzLnBvcCgpOwoKICAgICAgICAgICAgY29udGludWU7CgogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsKICAgICAgICAgICAgICBfID0gMDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkgewogICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7CiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07CiAgICAgICAgICAgICAgdCA9IG9wOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgewogICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdOwoKICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTsKCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTsKCiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsKCiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KCiAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBvcCA9IFs2LCBlXTsKICAgICAgICB5ID0gMDsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBmID0gdCA9IDA7CiAgICAgIH0KICAgIH0KCiAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsKICAgIHJldHVybiB7CiAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLAogICAgICBkb25lOiB0cnVlCiAgICB9OwogIH0KfQoKZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7CiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7CiAgICBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7CiAgfQoKICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIHsKICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSB7CiAgICAgIHJba10gPSBhW2pdOwogICAgfQogIH0KCiAgcmV0dXJuIHI7Cn0KCmZ1bmN0aW9uIHN0YXRpY1N0YXRlR2VuZXJhdG9yKG1vZHVsZSwgbW9kT3B0LCBzdGF0aWNzKSB7CiAgdmFyIHN0YXRlID0gbW9kT3B0LnN0YXRlRmFjdG9yeSA/IG1vZHVsZS5zdGF0ZSgpIDogbW9kdWxlLnN0YXRlOwogIE9iamVjdC5rZXlzKHN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgIC8vIElmIG5vdCB1bmRlZmluZWQgb3IgZnVuY3Rpb24gbWVhbnMgaXQgaXMgYSBzdGF0ZSB2YWx1ZQogICAgICBpZiAoWyd1bmRlZmluZWQnLCAnZnVuY3Rpb24nXS5pbmRleE9mKF90eXBlb2Yoc3RhdGVba2V5XSkpID09PSAtMSkgewogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGF0aWNzLCBrZXksIHsKICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgICByZXR1cm4gc3RhdGljcy5zdG9yZS5zdGF0ZVttb2RPcHQubmFtZV1ba2V5XTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgfQogIH0pOwp9CgpmdW5jdGlvbiBzdGF0aWNHZXR0ZXJHZW5lcmF0b3IobW9kdWxlLCBtb2RPcHQsIHN0YXRpY3MpIHsKICBPYmplY3Qua2V5cyhtb2R1bGUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0YXRpY3MsIGtleSwgewogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHN0YXRpY3Muc3RvcmUuZ2V0dGVyc1ttb2RPcHQubmFtZSArICIvIiArIGtleV07CiAgICAgICAgfQogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGF0aWNzLCBrZXksIHsKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiBzdGF0aWNzLnN0b3JlLmdldHRlcnNba2V5XTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0pOwp9CgpmdW5jdGlvbiBzdGF0aWNNdXRhdGlvbkdlbmVyYXRvcihtb2R1bGUsIG1vZE9wdCwgc3RhdGljcykgewogIE9iamVjdC5rZXlzKG1vZHVsZS5tdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7CiAgICAgIHN0YXRpY3Nba2V5XSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgX2E7CgogICAgICAgIHZhciBhcmdzID0gW107CgogICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07CiAgICAgICAgfQoKICAgICAgICAoX2EgPSBzdGF0aWNzLnN0b3JlKS5jb21taXQuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXlzKFttb2RPcHQubmFtZSArICIvIiArIGtleV0sIGFyZ3MpKTsKICAgICAgfTsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRpY3Nba2V5XSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgX2E7CgogICAgICAgIHZhciBhcmdzID0gW107CgogICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07CiAgICAgICAgfQoKICAgICAgICAoX2EgPSBzdGF0aWNzLnN0b3JlKS5jb21taXQuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXlzKFtrZXldLCBhcmdzKSk7CiAgICAgIH07CiAgICB9CiAgfSk7Cn0KCmZ1bmN0aW9uIHN0YXRpY0FjdGlvbkdlbmVyYXRvcnMobW9kdWxlLCBtb2RPcHQsIHN0YXRpY3MpIHsKICBPYmplY3Qua2V5cyhtb2R1bGUuYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHsKICAgICAgc3RhdGljc1trZXldID0gZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBhcmdzID0gW107CgogICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgX2E7CgogICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikgewogICAgICAgICAgICByZXR1cm4gWzIKICAgICAgICAgICAgLypyZXR1cm4qLwogICAgICAgICAgICAsIChfYSA9IHN0YXRpY3Muc3RvcmUpLmRpc3BhdGNoLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5cyhbbW9kT3B0Lm5hbWUgKyAiLyIgKyBrZXldLCBhcmdzKSldOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICB9IGVsc2UgewogICAgICBzdGF0aWNzW2tleV0gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBbXTsKCiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHsKICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsKICAgICAgICB9CgogICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBfYTsKCiAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7CiAgICAgICAgICAgIHJldHVybiBbMgogICAgICAgICAgICAvKnJldHVybiovCiAgICAgICAgICAgICwgKF9hID0gc3RhdGljcy5zdG9yZSkuZGlzcGF0Y2guYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXlzKFtrZXldLCBhcmdzKSldOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICB9CiAgfSk7Cn0KCmZ1bmN0aW9uIHJlZ2lzdGVyRHluYW1pY01vZHVsZShtb2R1bGUsIG1vZE9wdCkgewogIGlmICghbW9kT3B0Lm5hbWUpIHsKICAgIHRocm93IG5ldyBFcnJvcignTmFtZSBvZiBtb2R1bGUgbm90IHByb3ZpZGVkIGluIGRlY29yYXRvciBvcHRpb25zJyk7CiAgfQoKICBpZiAoIW1vZE9wdC5zdG9yZSkgewogICAgdGhyb3cgbmV3IEVycm9yKCdTdG9yZSBub3QgcHJvdmlkZWQgaW4gZGVjb3JhdG9yIG9wdGlvbnMgd2hlbiB1c2luZyBkeW5hbWljIG9wdGlvbicpOwogIH0KCiAgbW9kT3B0LnN0b3JlLnJlZ2lzdGVyTW9kdWxlKG1vZE9wdC5uYW1lLCAvLyBUT0RPOiBIYW5kbGUgbmVzdGVkIG1vZHVsZXMgdG9vIGluIGZ1dHVyZQogIG1vZHVsZSwgewogICAgcHJlc2VydmVTdGF0ZTogbW9kT3B0LnByZXNlcnZlU3RhdGUgfHwgZmFsc2UKICB9KTsKfQoKZnVuY3Rpb24gbW9kdWxlRGVjb3JhdG9yRmFjdG9yeShtb2R1bGVPcHRpb25zKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChjb25zdHJ1Y3RvcikgewogICAgdmFyIG1vZHVsZSA9IGNvbnN0cnVjdG9yOwoKICAgIHZhciBzdGF0ZUZhY3RvcnkkMSA9IGZ1bmN0aW9uIHN0YXRlRmFjdG9yeSQxKCkgewogICAgICByZXR1cm4gc3RhdGVGYWN0b3J5KG1vZHVsZSk7CiAgICB9OwoKICAgIGlmICghbW9kdWxlLnN0YXRlKSB7CiAgICAgIG1vZHVsZS5zdGF0ZSA9IG1vZHVsZU9wdGlvbnMgJiYgbW9kdWxlT3B0aW9ucy5zdGF0ZUZhY3RvcnkgPyBzdGF0ZUZhY3RvcnkkMSA6IHN0YXRlRmFjdG9yeSQxKCk7CiAgICB9CgogICAgaWYgKCFtb2R1bGUuZ2V0dGVycykgewogICAgICBtb2R1bGUuZ2V0dGVycyA9IHt9OwogICAgfQoKICAgIGlmICghbW9kdWxlLm5hbWVzcGFjZWQpIHsKICAgICAgbW9kdWxlLm5hbWVzcGFjZWQgPSBtb2R1bGVPcHRpb25zICYmIG1vZHVsZU9wdGlvbnMubmFtZXNwYWNlZDsKICAgIH0KCiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2R1bGUucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jTmFtZSkgewogICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobW9kdWxlLnByb3RvdHlwZSwgZnVuY05hbWUpOwoKICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICYmIG1vZHVsZS5nZXR0ZXJzKSB7CiAgICAgICAgbW9kdWxlLmdldHRlcnNbZnVuY05hbWVdID0gZnVuY3Rpb24gKHN0YXRlLCBnZXR0ZXJzLCByb290U3RhdGUsIHJvb3RHZXR0ZXJzKSB7CiAgICAgICAgICB2YXIgdGhpc09iaiA9IHsKICAgICAgICAgICAgY29udGV4dDogewogICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSwKICAgICAgICAgICAgICBnZXR0ZXJzOiBnZXR0ZXJzLAogICAgICAgICAgICAgIHJvb3RTdGF0ZTogcm9vdFN0YXRlLAogICAgICAgICAgICAgIHJvb3RHZXR0ZXJzOiByb290R2V0dGVycwogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgYWRkUHJvcGVydGllc1RvT2JqZWN0KHRoaXNPYmosIHN0YXRlKTsKICAgICAgICAgIGFkZFByb3BlcnRpZXNUb09iamVjdCh0aGlzT2JqLCBnZXR0ZXJzKTsKICAgICAgICAgIHZhciBnb3QgPSBkZXNjcmlwdG9yLmdldC5jYWxsKHRoaXNPYmopOwogICAgICAgICAgcmV0dXJuIGdvdDsKICAgICAgICB9OwogICAgICB9CiAgICB9KTsKICAgIHZhciBtb2RPcHQgPSBtb2R1bGVPcHRpb25zOwoKICAgIGlmIChtb2RPcHQubmFtZSkgewogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdfZ2VuU3RhdGljJywgewogICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShzdG9yZSkgewogICAgICAgICAgdmFyIHN0YXRpY3MgPSB7CiAgICAgICAgICAgIHN0b3JlOiBzdG9yZSB8fCBtb2RPcHQuc3RvcmUKICAgICAgICAgIH07CgogICAgICAgICAgaWYgKCFzdGF0aWNzLnN0b3JlKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiRVJSX1NUT1JFX05PVF9QUk9WSURFRDogVG8gdXNlIGdldE1vZHVsZSgpLCBlaXRoZXIgdGhlIG1vZHVsZVxuICAgICAgICAgICAgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoIHN0b3JlIGluIGRlY29yYXRvciwgaS5lLiBATW9kdWxlKHtzdG9yZTogc3RvcmV9KSBvclxuICAgICAgICAgICAgc3RvcmUgc2hvdWxkIGJlIHBhc3NlZCB3aGVuIGNhbGxpbmcgZ2V0TW9kdWxlKCksIGkuZS4gZ2V0TW9kdWxlKE15TW9kdWxlLCB0aGlzLiRzdG9yZSkiKTsKICAgICAgICAgIH0gLy8gPT09PT09PT09PT0gIEZvciBzdGF0aWNzID09PT09PT09PT09PT09CiAgICAgICAgICAvLyAtLS0tLS0gc3RhdGUgLS0tLS0tLQoKCiAgICAgICAgICBzdGF0aWNTdGF0ZUdlbmVyYXRvcihtb2R1bGUsIG1vZE9wdCwgc3RhdGljcyk7IC8vIC0tLS0tLS0gZ2V0dGVycyAtLS0tLS0tCgogICAgICAgICAgaWYgKG1vZHVsZS5nZXR0ZXJzKSB7CiAgICAgICAgICAgIHN0YXRpY0dldHRlckdlbmVyYXRvcihtb2R1bGUsIG1vZE9wdCwgc3RhdGljcyk7CiAgICAgICAgICB9IC8vIC0tLS0tLS0tIG11dGF0aW9ucyAtLS0tLS0tLQoKCiAgICAgICAgICBpZiAobW9kdWxlLm11dGF0aW9ucykgewogICAgICAgICAgICBzdGF0aWNNdXRhdGlvbkdlbmVyYXRvcihtb2R1bGUsIG1vZE9wdCwgc3RhdGljcyk7CiAgICAgICAgICB9IC8vIC0tLS0tLS0tIGFjdGlvbnMgLS0tLS0tLS0tCgoKICAgICAgICAgIGlmIChtb2R1bGUuYWN0aW9ucykgewogICAgICAgICAgICBzdGF0aWNBY3Rpb25HZW5lcmF0b3JzKG1vZHVsZSwgbW9kT3B0LCBzdGF0aWNzKTsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gc3RhdGljczsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdfdm1kTW9kdWxlTmFtZScsIHsKICAgICAgICB2YWx1ZTogbW9kT3B0Lm5hbWUKICAgICAgfSk7CiAgICB9CgogICAgaWYgKG1vZE9wdC5keW5hbWljKSB7CiAgICAgIHJlZ2lzdGVyRHluYW1pY01vZHVsZShtb2R1bGUsIG1vZE9wdCk7CiAgICB9CgogICAgcmV0dXJuIGNvbnN0cnVjdG9yOwogIH07Cn0KCmZ1bmN0aW9uIE1vZHVsZShtb2RPck9wdCkgewogIGlmICh0eXBlb2YgbW9kT3JPcHQgPT09ICdmdW5jdGlvbicpIHsKICAgIC8qDQogICAgICogQE1vZHVsZSBkZWNvcmF0b3IgY2FsbGVkIHdpdGhvdXQgb3B0aW9ucyAoZGlyZWN0bHkgb24gdGhlIGNsYXNzIGRlZmluaXRpb24pDQogICAgICovCiAgICBtb2R1bGVEZWNvcmF0b3JGYWN0b3J5KHt9KShtb2RPck9wdCk7CiAgfSBlbHNlIHsKICAgIC8qDQogICAgICogQE1vZHVsZSh7Li4ufSkgZGVjb3JhdG9yIGNhbGxlZCB3aXRoIG9wdGlvbnMNCiAgICAgKi8KICAgIHJldHVybiBtb2R1bGVEZWNvcmF0b3JGYWN0b3J5KG1vZE9yT3B0KTsKICB9Cn0KCnZhciBjb25maWcgPSB7fTsKCmZ1bmN0aW9uIGFjdGlvbkRlY29yYXRvckZhY3RvcnkocGFyYW1zKSB7CiAgdmFyIF9hID0gcGFyYW1zIHx8IHt9LAogICAgICBfYiA9IF9hLmNvbW1pdCwKICAgICAgY29tbWl0ID0gX2IgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9iLAogICAgICBfYyA9IF9hLnJhd0Vycm9yLAogICAgICByYXdFcnJvciA9IF9jID09PSB2b2lkIDAgPyAhIWNvbmZpZy5yYXdFcnJvciA6IF9jLAogICAgICBfZCA9IF9hLnJvb3QsCiAgICAgIHJvb3QgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDsKCiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikgewogICAgdmFyIG1vZHVsZSA9IHRhcmdldC5jb25zdHJ1Y3RvcjsKCiAgICBpZiAoIW1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnYWN0aW9ucycpKSB7CiAgICAgIG1vZHVsZS5hY3Rpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kdWxlLmFjdGlvbnMpOwogICAgfQoKICAgIHZhciBhY3Rpb25GdW5jdGlvbiA9IGRlc2NyaXB0b3IudmFsdWU7CgogICAgdmFyIGFjdGlvbiA9IGZ1bmN0aW9uIGFjdGlvbihjb250ZXh0LCBwYXlsb2FkKSB7CiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgYWN0aW9uUGF5bG9hZCwgbW9kdWxlTmFtZSwgbW9kdWxlQWNjZXNzb3IsIHRoaXNPYmosIGVfMTsKICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7CiAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7CiAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDUsLCA2XSk7CgogICAgICAgICAgICAgIGFjdGlvblBheWxvYWQgPSBudWxsOwogICAgICAgICAgICAgIGlmICghbW9kdWxlLl9nZW5TdGF0aWMpIHJldHVybiBbMwogICAgICAgICAgICAgIC8qYnJlYWsqLwogICAgICAgICAgICAgICwgMl07CiAgICAgICAgICAgICAgbW9kdWxlTmFtZSA9IGdldE1vZHVsZU5hbWUobW9kdWxlKTsKICAgICAgICAgICAgICBtb2R1bGVBY2Nlc3NvciA9IGNvbnRleHQucm9vdEdldHRlcnNbbW9kdWxlTmFtZV0gPyBjb250ZXh0LnJvb3RHZXR0ZXJzW21vZHVsZU5hbWVdIDogZ2V0TW9kdWxlKG1vZHVsZSk7CiAgICAgICAgICAgICAgbW9kdWxlQWNjZXNzb3IuY29udGV4dCA9IGNvbnRleHQ7CiAgICAgICAgICAgICAgcmV0dXJuIFs0CiAgICAgICAgICAgICAgLyp5aWVsZCovCiAgICAgICAgICAgICAgLCBhY3Rpb25GdW5jdGlvbi5jYWxsKG1vZHVsZUFjY2Vzc29yLCBwYXlsb2FkKV07CgogICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgYWN0aW9uUGF5bG9hZCA9IF9hLnNlbnQoKTsKICAgICAgICAgICAgICByZXR1cm4gWzMKICAgICAgICAgICAgICAvKmJyZWFrKi8KICAgICAgICAgICAgICAsIDRdOwoKICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgIHRoaXNPYmogPSB7CiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBhZGRQcm9wZXJ0aWVzVG9PYmplY3QodGhpc09iaiwgY29udGV4dC5zdGF0ZSk7CiAgICAgICAgICAgICAgYWRkUHJvcGVydGllc1RvT2JqZWN0KHRoaXNPYmosIGNvbnRleHQuZ2V0dGVycyk7CiAgICAgICAgICAgICAgcmV0dXJuIFs0CiAgICAgICAgICAgICAgLyp5aWVsZCovCiAgICAgICAgICAgICAgLCBhY3Rpb25GdW5jdGlvbi5jYWxsKHRoaXNPYmosIHBheWxvYWQpXTsKCiAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICBhY3Rpb25QYXlsb2FkID0gX2Euc2VudCgpOwogICAgICAgICAgICAgIF9hLmxhYmVsID0gNDsKCiAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICBpZiAoY29tbWl0KSB7CiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbW1pdChjb21taXQsIGFjdGlvblBheWxvYWQpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIFsyCiAgICAgICAgICAgICAgLypyZXR1cm4qLwogICAgICAgICAgICAgICwgYWN0aW9uUGF5bG9hZF07CgogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpOwogICAgICAgICAgICAgIHRocm93IHJhd0Vycm9yID8gZV8xIDogbmV3IEVycm9yKCdFUlJfQUNUSU9OX0FDQ0VTU19VTkRFRklORUQ6IEFyZSB5b3UgdHJ5aW5nIHRvIGFjY2VzcyAnICsgJ3RoaXMuc29tZU11dGF0aW9uKCkgb3IgdGhpcy5zb21lR2V0dGVyIGluc2lkZSBhbiBAQWN0aW9uPyBcbicgKyAnVGhhdCB3b3JrcyBvbmx5IGluIGR5bmFtaWMgbW9kdWxlcy4gXG4nICsgJ0lmIG5vdCBkeW5hbWljIHVzZSB0aGlzLmNvbnRleHQuY29tbWl0KCJtdXRhdGlvbk5hbWUiLCBwYXlsb2FkKSAnICsgJ2FuZCB0aGlzLmNvbnRleHQuZ2V0dGVyc1siZ2V0dGVyTmFtZSJdJyArICdcbicgKyBuZXcgRXJyb3IoIkNvdWxkIG5vdCBwZXJmb3JtIGFjdGlvbiAiICsga2V5LnRvU3RyaW5nKCkpLnN0YWNrICsgJ1xuJyArIGVfMS5zdGFjayk7CgogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgcmV0dXJuIFsyCiAgICAgICAgICAgICAgLypyZXR1cm4qLwogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfTsKCiAgICBtb2R1bGUuYWN0aW9uc1trZXldID0gcm9vdCA/IHsKICAgICAgcm9vdDogcm9vdCwKICAgICAgaGFuZGxlcjogYWN0aW9uCiAgICB9IDogYWN0aW9uOwogIH07Cn0KLyoqDQogKiBUaGUgQEFjdGlvbiBkZWNvcmF0b3IgdHVybnMgYW4gYXN5bmMgZnVuY3Rpb24gaW50byBhbiBWdWV4IGFjdGlvbg0KICoNCiAqIEBwYXJhbSB0YXJnZXRPclBhcmFtcyB0aGUgbW9kdWxlIGNsYXNzDQogKiBAcGFyYW0ga2V5IG5hbWUgb2YgdGhlIGFjdGlvbg0KICogQHBhcmFtIGRlc2NyaXB0b3IgdGhlIGFjdGlvbiBmdW5jdGlvbiBkZXNjcmlwdG9yDQogKiBAY29uc3RydWN0b3INCiAqLwoKCmZ1bmN0aW9uIEFjdGlvbih0YXJnZXRPclBhcmFtcywga2V5LCBkZXNjcmlwdG9yKSB7CiAgaWYgKCFrZXkgJiYgIWRlc2NyaXB0b3IpIHsKICAgIC8qDQogICAgICogVGhpcyBpcyB0aGUgY2FzZSB3aGVuIGB0YXJnZXRPclBhcmFtc2AgaXMgcGFyYW1zLg0KICAgICAqIGkuZS4gd2hlbiB1c2VkIGFzIC0NCiAgICAgKiA8cHJlPg0KICAgICAgICBAQWN0aW9uKHtjb21taXQ6ICdpbmNyQ291bnQnfSkNCiAgICAgICAgYXN5bmMgZ2V0Q291bnREZWx0YSgpIHsNCiAgICAgICAgICByZXR1cm4gNQ0KICAgICAgICB9DQogICAgICogPC9wcmU+DQogICAgICovCiAgICByZXR1cm4gYWN0aW9uRGVjb3JhdG9yRmFjdG9yeSh0YXJnZXRPclBhcmFtcyk7CiAgfSBlbHNlIHsKICAgIC8qDQogICAgICogVGhpcyBpcyB0aGUgY2FzZSB3aGVuIEBBY3Rpb24gaXMgY2FsbGVkIG9uIGFjdGlvbiBmdW5jdGlvbg0KICAgICAqIHdpdGhvdXQgYW55IHBhcmFtcw0KICAgICAqIDxwcmU+DQogICAgICogICBAQWN0aW9uDQogICAgICogICBhc3luYyBkb1NvbWV0aGluZygpIHsNCiAgICAgKiAgICAuLi4NCiAgICAgKiAgIH0NCiAgICAgKiA8L3ByZT4NCiAgICAgKi8KICAgIGFjdGlvbkRlY29yYXRvckZhY3RvcnkoKSh0YXJnZXRPclBhcmFtcywga2V5LCBkZXNjcmlwdG9yKTsKICB9Cn0KCmZ1bmN0aW9uIE11dGF0aW9uKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7CiAgdmFyIG1vZHVsZSA9IHRhcmdldC5jb25zdHJ1Y3RvcjsKCiAgaWYgKCFtb2R1bGUuaGFzT3duUHJvcGVydHkoJ211dGF0aW9ucycpKSB7CiAgICBtb2R1bGUubXV0YXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kdWxlLm11dGF0aW9ucyk7CiAgfQoKICB2YXIgbXV0YXRpb25GdW5jdGlvbiA9IGRlc2NyaXB0b3IudmFsdWU7CgogIHZhciBtdXRhdGlvbiA9IGZ1bmN0aW9uIG11dGF0aW9uKHN0YXRlLCBwYXlsb2FkKSB7CiAgICBtdXRhdGlvbkZ1bmN0aW9uLmNhbGwoc3RhdGUsIHBheWxvYWQpOwogIH07CgogIG1vZHVsZS5tdXRhdGlvbnNba2V5XSA9IG11dGF0aW9uOwp9CgpmdW5jdGlvbiBtdXRhdGlvbkFjdGlvbkRlY29yYXRvckZhY3RvcnkocGFyYW1zKSB7CiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikgewogICAgdmFyIG1vZHVsZSA9IHRhcmdldC5jb25zdHJ1Y3RvcjsKCiAgICBpZiAoIW1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnbXV0YXRpb25zJykpIHsKICAgICAgbW9kdWxlLm11dGF0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZS5tdXRhdGlvbnMpOwogICAgfQoKICAgIGlmICghbW9kdWxlLmhhc093blByb3BlcnR5KCdhY3Rpb25zJykpIHsKICAgICAgbW9kdWxlLmFjdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBtb2R1bGUuYWN0aW9ucyk7CiAgICB9CgogICAgdmFyIG11dGFjdEZ1bmN0aW9uID0gZGVzY3JpcHRvci52YWx1ZTsKCiAgICB2YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKGNvbnRleHQsIHBheWxvYWQpIHsKICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBhY3Rpb25QYXlsb2FkLCBlXzE7CiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkgewogICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCwgM10pOwoKICAgICAgICAgICAgICByZXR1cm4gWzQKICAgICAgICAgICAgICAvKnlpZWxkKi8KICAgICAgICAgICAgICAsIG11dGFjdEZ1bmN0aW9uLmNhbGwoY29udGV4dCwgcGF5bG9hZCldOwoKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgIGFjdGlvblBheWxvYWQgPSBfYS5zZW50KCk7CiAgICAgICAgICAgICAgY29udGV4dC5jb21taXQoa2V5LCBhY3Rpb25QYXlsb2FkKTsKICAgICAgICAgICAgICByZXR1cm4gWzMKICAgICAgICAgICAgICAvKmJyZWFrKi8KICAgICAgICAgICAgICAsIDNdOwoKICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTsKCiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yYXdFcnJvcikgewogICAgICAgICAgICAgICAgdGhyb3cgZV8xOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgcGVyZm9ybSBhY3Rpb24gJyArIGtleS50b1N0cmluZygpKTsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZV8xKTsKICAgICAgICAgICAgICAgIHJldHVybiBbMgogICAgICAgICAgICAgICAgLypyZXR1cm4qLwogICAgICAgICAgICAgICAgLCBQcm9taXNlLnJlamVjdChlXzEpXTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgcmV0dXJuIFsyCiAgICAgICAgICAgICAgLypyZXR1cm4qLwogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfTsKCiAgICB2YXIgbXV0YXRpb24gPSBmdW5jdGlvbiBtdXRhdGlvbihzdGF0ZSwgcGF5bG9hZCkgewogICAgICBpZiAoIXBhcmFtcy5tdXRhdGUpIHsKICAgICAgICBwYXJhbXMubXV0YXRlID0gT2JqZWN0LmtleXMocGF5bG9hZCk7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXJhbXMubXV0YXRlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykgewogICAgICAgIHZhciBzdGF0ZUl0ZW0gPSBfYVtfaV07CgogICAgICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eShzdGF0ZUl0ZW0pICYmIHBheWxvYWQuaGFzT3duUHJvcGVydHkoc3RhdGVJdGVtKSkgewogICAgICAgICAgc3RhdGVbc3RhdGVJdGVtXSA9IHBheWxvYWRbc3RhdGVJdGVtXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJFUlJfTVVUQVRFX1BBUkFNU19OT1RfSU5fUEFZTE9BRFxuICAgICAgICAgIEluIEBNdXRhdGlvbkFjdGlvbiwgbXV0YXRlOiBbJ2EnLCAnYicsIC4uLl0gYXJyYXkga2V5cyBtdXN0XG4gICAgICAgICAgbWF0Y2ggd2l0aCByZXR1cm4gdHlwZSA9IHthOiB7fSwgYjoge30sIC4uLn0gYW5kIG11c3RcbiAgICAgICAgICBhbHNvIGJlIGluIHN0YXRlLiIpOwogICAgICAgIH0KICAgICAgfQogICAgfTsKCiAgICBtb2R1bGUuYWN0aW9uc1trZXldID0gcGFyYW1zLnJvb3QgPyB7CiAgICAgIHJvb3Q6IHRydWUsCiAgICAgIGhhbmRsZXI6IGFjdGlvbgogICAgfSA6IGFjdGlvbjsKICAgIG1vZHVsZS5tdXRhdGlvbnNba2V5XSA9IG11dGF0aW9uOwogIH07Cn0KLyoqDQogKiBUaGUgQE11dGF0aW9uQWN0aW9uIGRlY29yYXRvciB0dXJucyB0aGlzIGludG8gYW4gYWN0aW9uIHRoYXQgZnVydGhlciBjYWxscyBhIG11dGF0aW9uDQogKiBCb3RoIHRoZSBhY3Rpb24gYW5kIHRoZSBtdXRhdGlvbiBhcmUgZ2VuZXJhdGVkIGZvciB5b3UNCiAqDQogKiBAcGFyYW0gcGFyYW1zT3JUYXJnZXQgdGhlIHBhcmFtcyBvciB0aGUgdGFyZ2V0IGNsYXNzDQogKiBAcGFyYW0ga2V5IHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbg0KICogQHBhcmFtIGRlc2NyaXB0b3IgdGhlIGZ1bmN0aW9uIGJvZHkNCiAqIEBjb25zdHJ1Y3Rvcg0KICovCgoKZnVuY3Rpb24gTXV0YXRpb25BY3Rpb24ocGFyYW1zT3JUYXJnZXQsIGtleSwgZGVzY3JpcHRvcikgewogIGlmICgha2V5ICYmICFkZXNjcmlwdG9yKSB7CiAgICAvKg0KICAgICAqIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBgcGFyYW1zT3JUYXJnZXRgIGlzIHBhcmFtcy4NCiAgICAgKiBpLmUuIHdoZW4gdXNlZCBhcyAtDQogICAgICogPHByZT4NCiAgICAgICAgQE11dGF0aW9uQWN0aW9uKHttdXRhdGU6IFsnaW5jckNvdW50J119KQ0KICAgICAgICBhc3luYyBnZXRDb3VudERlbHRhKCkgew0KICAgICAgICAgIHJldHVybiB7aW5jckNvdW50OiA1fQ0KICAgICAgICB9DQogICAgICogPC9wcmU+DQogICAgICovCiAgICByZXR1cm4gbXV0YXRpb25BY3Rpb25EZWNvcmF0b3JGYWN0b3J5KHBhcmFtc09yVGFyZ2V0KTsKICB9IGVsc2UgewogICAgLyoNCiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gYHBhcmFtc09yVGFyZ2V0YCBpcyB0YXJnZXQuDQogICAgICogaS5lLiB3aGVuIHVzZWQgYXMgLQ0KICAgICAqIDxwcmU+DQogICAgICAgIEBNdXRhdGlvbkFjdGlvbg0KICAgICAgICBhc3luYyBnZXRDb3VudERlbHRhKCkgew0KICAgICAgICAgIHJldHVybiB7aW5jckNvdW50OiA1fQ0KICAgICAgICB9DQogICAgICogPC9wcmU+DQogICAgICovCiAgICBtdXRhdGlvbkFjdGlvbkRlY29yYXRvckZhY3Rvcnkoe30pKHBhcmFtc09yVGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpOwogIH0KfQoKZXhwb3J0IHsgQWN0aW9uLCBNb2R1bGUsIE11dGF0aW9uLCBNdXRhdGlvbkFjdGlvbiwgVnVleE1vZHVsZSwgY29uZmlnLCBnZXRNb2R1bGUgfTs="},{"version":3,"sources":["../../src/helpers.ts","../../src/vuexmodule.ts","../../src/module/stateFactory.ts","../../src/module/staticGenerators.ts","../../src/module/index.ts","../../src/config.ts","../../src/action.ts","../../src/mutation.ts","../../src/mutationaction.ts"],"names":["stateFactory"],"mappings":"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","sourcesContent":["/**\n * Takes the properties on object from parameter source and adds them to the object\n * parameter target\n * @param {object} target  Object to have properties copied onto from y\n * @param {object} source  Object with properties to be copied to x\n */\nexport function addPropertiesToObject(target: any, source: any) {\n  for (let k of Object.keys(source || {})) {\n    Object.defineProperty(target, k, {\n      get: () => source[k]\n    })\n  }\n}\n\n/**\n * Returns a namespaced name of the module to be used as a store getter\n * @param module\n */\nexport function getModuleName(module: any): string {\n  if (!module._vmdModuleName) {\n    throw new Error(`ERR_GET_MODULE_NAME : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n  return `vuexModuleDecorators/${module._vmdModuleName}`\n}\n","import {\n  ActionTree,\n  GetterTree,\n  Module as Mod,\n  ModuleTree,\n  MutationTree,\n  Store,\n  ActionContext\n} from 'vuex'\nimport { getModuleName } from './helpers'\n\nexport class VuexModule<S = ThisType<any>, R = any> implements Mod<S, R> {\n  /*\n   * To use with `extends Class` syntax along with decorators\n   */\n  static namespaced?: boolean\n  static state?: any | (() => any)\n  static getters?: GetterTree<any, any>\n  static actions?: ActionTree<any, any>\n  static mutations?: MutationTree<any>\n  static modules?: ModuleTree<any>\n\n  /*\n   * To use with `new VuexModule(<ModuleOptions>{})` syntax\n   */\n\n  modules?: ModuleTree<any>\n  namespaced?: boolean\n  getters?: GetterTree<S, R>\n  state?: S | (() => S)\n  mutations?: MutationTree<S>\n  actions?: ActionTree<S, R>\n  context!: ActionContext<S, R>\n\n  constructor(module: Mod<S, any>) {\n    this.actions = module.actions\n    this.mutations = module.mutations\n    this.state = module.state\n    this.getters = module.getters\n    this.namespaced = module.namespaced\n    this.modules = module.modules\n  }\n}\ntype ConstructorOf<C> = { new (...args: any[]): C }\n\nexport function getModule<M extends VuexModule>(\n  moduleClass: ConstructorOf<M>,\n  store?: Store<any>\n): M {\n  const moduleName = getModuleName(moduleClass)\n  if (store && store.getters[moduleName]) {\n    return store.getters[moduleName]\n  } else if ((moduleClass as any)._statics) {\n    return (moduleClass as any)._statics\n  }\n\n  const genStatic: (providedStore?: Store<any>) => M = (moduleClass as any)._genStatic\n  if (!genStatic) {\n    throw new Error(`ERR_GET_MODULE_NO_STATICS : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n\n  const storeModule = genStatic(store)\n\n  if (store) {\n    store.getters[moduleName] = storeModule\n  } else {\n    ;(moduleClass as any)._statics = storeModule\n  }\n\n  return storeModule\n}\n","import { Module as Mod } from 'vuex'\n\nconst reservedKeys = ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\nexport function stateFactory<S>(module: Function & Mod<S, any>) {\n  const state = new module.prototype.constructor({})\n  const s = {} as S\n  Object.keys(state).forEach((key: string) => {\n    if (reservedKeys.indexOf(key) !== -1) {\n      if (typeof state[key] !== 'undefined') {\n        throw new Error(\n          `ERR_RESERVED_STATE_KEY_USED: You cannot use the following\n        ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\n        as fields in your module. These are reserved as they have special purpose in Vuex`\n        )\n      }\n      return\n    }\n    if (state.hasOwnProperty(key)) {\n      if (typeof state[key] !== 'function') {\n        ;(s as any)[key] = state[key]\n      }\n    }\n  })\n\n  return s\n}\n","import { ActionTree, GetterTree, Module as Mod, MutationTree } from 'vuex'\nimport { DynamicModuleOptions } from '../moduleoptions'\n\nexport function staticStateGenerator<S extends Object>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  const state: S = modOpt.stateFactory ? (module as any).state() : module.state\n  Object.keys(state).forEach((key) => {\n    if (state.hasOwnProperty(key)) {\n      // If not undefined or function means it is a state value\n      if (['undefined', 'function'].indexOf(typeof (state as any)[key]) === -1) {\n        Object.defineProperty(statics, key, {\n          get() {\n            return statics.store.state[modOpt.name][key]\n          }\n        })\n      }\n    }\n  })\n}\n\nexport function staticGetterGenerator<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.getters as GetterTree<S, any>).forEach((key) => {\n    if (module.namespaced) {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[`${modOpt.name}/${key}`]\n        }\n      })\n    } else {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[key]\n        }\n      })\n    }\n  })\n}\n\nexport function staticMutationGenerator<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.mutations as MutationTree<S>).forEach((key) => {\n    if (module.namespaced) {\n      statics[key] = function(...args: any[]) {\n        statics.store.commit(`${modOpt.name}/${key}`, ...args)\n      }\n    } else {\n      statics[key] = function(...args: any[]) {\n        statics.store.commit(key, ...args)\n      }\n    }\n  })\n}\n\nexport function staticActionGenerators<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.actions as ActionTree<S, any>).forEach((key) => {\n    if (module.namespaced) {\n      statics[key] = async function(...args: any[]) {\n        return statics.store.dispatch(`${modOpt.name}/${key}`, ...args)\n      }\n    } else {\n      statics[key] = async function(...args: any[]) {\n        return statics.store.dispatch(key, ...args)\n      }\n    }\n  })\n}\n","import { GetterTree, Module as Mod, Store } from 'vuex'\nimport { DynamicModuleOptions, ModuleOptions } from '../moduleoptions'\nimport { stateFactory as sf } from './stateFactory'\nimport { addPropertiesToObject } from '../helpers'\nimport {\n  staticActionGenerators,\n  staticGetterGenerator,\n  staticMutationGenerator,\n  staticStateGenerator\n} from './staticGenerators'\n\nfunction registerDynamicModule<S>(module: Mod<S, any>, modOpt: DynamicModuleOptions) {\n  if (!modOpt.name) {\n    throw new Error('Name of module not provided in decorator options')\n  }\n\n  if (!modOpt.store) {\n    throw new Error('Store not provided in decorator options when using dynamic option')\n  }\n\n  modOpt.store.registerModule(\n    modOpt.name, // TODO: Handle nested modules too in future\n    module,\n    { preserveState: modOpt.preserveState || false }\n  )\n}\n\nfunction moduleDecoratorFactory<S>(moduleOptions: ModuleOptions) {\n  return function<TFunction extends Function>(constructor: TFunction): TFunction | void {\n    const module: Function & Mod<S, any> = constructor\n    const stateFactory = () => sf(module)\n\n    if (!module.state) {\n      module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory : stateFactory()\n    }\n    if (!module.getters) {\n      module.getters = {} as GetterTree<S, any>\n    }\n    if (!module.namespaced) {\n      module.namespaced = moduleOptions && moduleOptions.namespaced\n    }\n    Object.getOwnPropertyNames(module.prototype).forEach((funcName: string) => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        module.prototype,\n        funcName\n      ) as PropertyDescriptor\n      if (descriptor.get && module.getters) {\n        module.getters[funcName] = function(\n          state: S,\n          getters: GetterTree<S, any>,\n          rootState: any,\n          rootGetters: GetterTree<any, any>\n        ) {\n          const thisObj = { context: { state, getters, rootState, rootGetters } }\n          addPropertiesToObject(thisObj, state)\n          addPropertiesToObject(thisObj, getters)\n          const got = (descriptor.get as Function).call(thisObj)\n          return got\n        }\n      }\n    })\n    const modOpt = moduleOptions as DynamicModuleOptions\n    if (modOpt.name) {\n      Object.defineProperty(constructor, '_genStatic', {\n        value: (store?: Store<any>) => {\n          let statics = { store: store || modOpt.store }\n          if (!statics.store) {\n            throw new Error(`ERR_STORE_NOT_PROVIDED: To use getModule(), either the module\n            should be decorated with store in decorator, i.e. @Module({store: store}) or\n            store should be passed when calling getModule(), i.e. getModule(MyModule, this.$store)`)\n          }\n          // ===========  For statics ==============\n          // ------ state -------\n          staticStateGenerator(module, modOpt, statics)\n\n          // ------- getters -------\n          if (module.getters) {\n            staticGetterGenerator(module, modOpt, statics)\n          }\n\n          // -------- mutations --------\n          if (module.mutations) {\n            staticMutationGenerator(module, modOpt, statics)\n          }\n          // -------- actions ---------\n          if (module.actions) {\n            staticActionGenerators(module, modOpt, statics)\n          }\n          return statics\n        }\n      })\n\n      Object.defineProperty(constructor, '_vmdModuleName', {\n        value: modOpt.name\n      })\n    }\n\n    if (modOpt.dynamic) {\n      registerDynamicModule(module, modOpt)\n    }\n    return constructor\n  }\n}\n\nexport function Module<S>(module: Function & Mod<S, any>): void\nexport function Module<S>(options: ModuleOptions): ClassDecorator\n\nexport function Module<S>(modOrOpt: ModuleOptions | (Function & Mod<S, any>)) {\n  if (typeof (modOrOpt as any) === 'function') {\n    /*\n     * @Module decorator called without options (directly on the class definition)\n     */\n    moduleDecoratorFactory({})(modOrOpt as Function & Mod<S, any>)\n  } else {\n    /*\n     * @Module({...}) decorator called with options\n     */\n    return moduleDecoratorFactory(modOrOpt)\n  }\n}\n","export const config: IConfig = {}\n\nexport interface IConfig {\n  rawError?: boolean\n}\n","import { Action as Act, ActionContext, Module as Mod, Payload } from 'vuex'\nimport { getModule, VuexModule } from './vuexmodule'\nimport { addPropertiesToObject, getModuleName } from './helpers'\nimport { config } from './config'\n\n/**\n * Parameters that can be passed to the @Action decorator\n */\nexport interface ActionDecoratorParams {\n  commit?: string\n  rawError?: boolean\n  root?: boolean\n}\nfunction actionDecoratorFactory<T>(params?: ActionDecoratorParams): MethodDecorator {\n  const { commit = undefined, rawError = !!config.rawError, root = false } = params || {}\n  return function(target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<any>) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const actionFunction: Function = descriptor.value\n    const action: Act<typeof target, any> = async function(\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        let actionPayload = null\n\n        if ((module as any)._genStatic) {\n          const moduleName = getModuleName(module)\n          const moduleAccessor = context.rootGetters[moduleName]\n            ? context.rootGetters[moduleName]\n            : getModule(module as typeof VuexModule)\n          moduleAccessor.context = context\n          actionPayload = await actionFunction.call(moduleAccessor, payload)\n        } else {\n          const thisObj = { context }\n          addPropertiesToObject(thisObj, context.state)\n          addPropertiesToObject(thisObj, context.getters)\n          actionPayload = await actionFunction.call(thisObj, payload)\n        }\n        if (commit) {\n          context.commit(commit, actionPayload)\n        }\n        return actionPayload\n      } catch (e) {\n        throw rawError\n          ? e\n          : new Error(\n              'ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' +\n                'this.someMutation() or this.someGetter inside an @Action? \\n' +\n                'That works only in dynamic modules. \\n' +\n                'If not dynamic use this.context.commit(\"mutationName\", payload) ' +\n                'and this.context.getters[\"getterName\"]' +\n                '\\n' +\n                new Error(`Could not perform action ${key.toString()}`).stack +\n                '\\n' +\n                e.stack\n            )\n      }\n    }\n    module.actions![key as string] = root ? { root, handler: action } : action\n  }\n}\n\nexport function Action<T, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n): void\nexport function Action<T>(params: ActionDecoratorParams): MethodDecorator\n\n/**\n * The @Action decorator turns an async function into an Vuex action\n *\n * @param targetOrParams the module class\n * @param key name of the action\n * @param descriptor the action function descriptor\n * @constructor\n */\nexport function Action<T, R>(\n  targetOrParams: T | ActionDecoratorParams,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `targetOrParams` is params.\n     * i.e. when used as -\n     * <pre>\n        @Action({commit: 'incrCount'})\n        async getCountDelta() {\n          return 5\n        }\n     * </pre>\n     */\n    return actionDecoratorFactory(targetOrParams as ActionDecoratorParams)\n  } else {\n    /*\n     * This is the case when @Action is called on action function\n     * without any params\n     * <pre>\n     *   @Action\n     *   async doSomething() {\n     *    ...\n     *   }\n     * </pre>\n     */\n    actionDecoratorFactory()(targetOrParams, key!, descriptor!)\n  }\n}\n","import { Module as Mod, Mutation as Mut, Payload } from 'vuex'\n\nexport function Mutation<T extends Object, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  const module = target.constructor as Mod<T, any>\n  if (!module.hasOwnProperty('mutations')) {\n    module.mutations = Object.assign({}, module.mutations)\n  }\n  const mutationFunction: Function = descriptor.value!\n  const mutation: Mut<typeof target> = function(state: typeof target, payload: Payload) {\n    mutationFunction.call(state, payload)\n  }\n  module.mutations![key as string] = mutation\n}\n","import { Action as Act, ActionContext, Module as Mod, Mutation as Mut, Payload, Store } from 'vuex'\n\nexport interface MutationActionParams<M> {\n  mutate?: (keyof Partial<M>)[]\n  rawError?: boolean\n  root?: boolean\n}\n\nfunction mutationActionDecoratorFactory<T extends Object>(params: MutationActionParams<T>) {\n  return function(\n    target: T,\n    key: string | symbol,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T>>>\n  ) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('mutations')) {\n      module.mutations = Object.assign({}, module.mutations)\n    }\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const mutactFunction = descriptor.value as (payload: any) => Promise<any>\n\n    const action: Act<typeof target, any> = async function(\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        const actionPayload = await mutactFunction.call(context, payload)\n        context.commit(key as string, actionPayload)\n      } catch (e) {\n        if (params.rawError) {\n          throw e\n        } else {\n          console.error('Could not perform action ' + key.toString())\n          console.error(e)\n          return Promise.reject(e)\n        }\n      }\n    }\n\n    const mutation: Mut<typeof target> = function(\n      state: typeof target | Store<T>,\n      payload: Payload & { [k in keyof T]: any }\n    ) {\n      if (!params.mutate) {\n        params.mutate = Object.keys(payload) as (keyof T)[]\n      }\n      for (let stateItem of params.mutate) {\n        if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\n          ;(state as T)[stateItem] = payload[stateItem]\n        } else {\n          throw new Error(`ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\n          match with return type = {a: {}, b: {}, ...} and must\n          also be in state.`)\n        }\n      }\n    }\n    module.actions![key as string] = params.root ? { root: true, handler: action } : action\n    module.mutations![key as string] = mutation\n  }\n}\n\nexport function MutationAction<K, T extends K>(\n  target: { [k in keyof T]: T[k] | null },\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<K>>\n): void\n\nexport function MutationAction<T>(\n  params: MutationActionParams<T>\n): (\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<T>>\n) => void\n\n/**\n * The @MutationAction decorator turns this into an action that further calls a mutation\n * Both the action and the mutation are generated for you\n *\n * @param paramsOrTarget the params or the target class\n * @param key the name of the function\n * @param descriptor the function body\n * @constructor\n */\nexport function MutationAction<T, K, M extends K>(\n  paramsOrTarget: MutationActionParams<T> | M,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<K>>>\n):\n  | ((\n      target: T,\n      key: string | symbol,\n      descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T>>>\n    ) => void)\n  | void {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `paramsOrTarget` is params.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction({mutate: ['incrCount']})\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    return mutationActionDecoratorFactory(paramsOrTarget as MutationActionParams<T>)\n  } else {\n    /*\n     * This is the case when `paramsOrTarget` is target.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    mutationActionDecoratorFactory({} as MutationActionParams<K>)(\n      paramsOrTarget as K,\n      key!,\n      descriptor!\n    )\n  }\n}\n"]}]}